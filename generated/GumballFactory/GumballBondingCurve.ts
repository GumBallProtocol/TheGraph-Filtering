// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Borrow extends ethereum.Event {
  get params(): Borrow__Params {
    return new Borrow__Params(this);
  }
}

export class Borrow__Params {
  _event: Borrow;

  constructor(event: Borrow) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Burn extends ethereum.Event {
  get params(): Burn__Params {
    return new Burn__Params(this);
  }
}

export class Burn__Params {
  _event: Burn;

  constructor(event: Burn) {
    this._event = event;
  }

  get amount(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class Buy extends ethereum.Event {
  get params(): Buy__Params {
    return new Buy__Params(this);
  }
}

export class Buy__Params {
  _event: Buy;

  constructor(event: Buy) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Initialized extends ethereum.Event {
  get params(): Initialized__Params {
    return new Initialized__Params(this);
  }
}

export class Initialized__Params {
  _event: Initialized;

  constructor(event: Initialized) {
    this._event = event;
  }

  get version(): i32 {
    return this._event.parameters[0].value.toI32();
  }
}

export class Repay extends ethereum.Event {
  get params(): Repay__Params {
    return new Repay__Params(this);
  }
}

export class Repay__Params {
  _event: Repay;

  constructor(event: Repay) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Sell extends ethereum.Event {
  get params(): Sell__Params {
    return new Sell__Params(this);
  }
}

export class Sell__Params {
  _event: Sell;

  constructor(event: Sell) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Skim extends ethereum.Event {
  get params(): Skim__Params {
    return new Skim__Params(this);
  }
}

export class Skim__Params {
  _event: Skim;

  constructor(event: Skim) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class UpdateOwnership extends ethereum.Event {
  get params(): UpdateOwnership__Params {
    return new UpdateOwnership__Params(this);
  }
}

export class UpdateOwnership__Params {
  _event: UpdateOwnership;

  constructor(event: UpdateOwnership) {
    this._event = event;
  }

  get newOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class GumballBondingCurve extends ethereum.SmartContract {
  static bind(address: Address): GumballBondingCurve {
    return new GumballBondingCurve("GumballBondingCurve", address);
  }

  BASE_TOKEN(): Address {
    let result = super.call("BASE_TOKEN", "BASE_TOKEN():(address)", []);

    return result[0].toAddress();
  }

  try_BASE_TOKEN(): ethereum.CallResult<Address> {
    let result = super.tryCall("BASE_TOKEN", "BASE_TOKEN():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  INITIAL_VIRTUAL_BASE(): BigInt {
    let result = super.call(
      "INITIAL_VIRTUAL_BASE",
      "INITIAL_VIRTUAL_BASE():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_INITIAL_VIRTUAL_BASE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "INITIAL_VIRTUAL_BASE",
      "INITIAL_VIRTUAL_BASE():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  allowance(owner: Address, spender: Address): BigInt {
    let result = super.call(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)]
    );

    return result[0].toBigInt();
  }

  try_allowance(owner: Address, spender: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  approve(spender: Address, amount: BigInt): boolean {
    let result = super.call("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);

    return result[0].toBoolean();
  }

  try_approve(spender: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  artist(): Address {
    let result = super.call("artist", "artist():(address)", []);

    return result[0].toAddress();
  }

  try_artist(): ethereum.CallResult<Address> {
    let result = super.tryCall("artist", "artist():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  balanceOf(account: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  baseBal(): BigInt {
    let result = super.call("baseBal", "baseBal():(uint256)", []);

    return result[0].toBigInt();
  }

  try_baseBal(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("baseBal", "baseBal():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  borrowCredit(account: Address): BigInt {
    let result = super.call("borrowCredit", "borrowCredit(address):(uint256)", [
      ethereum.Value.fromAddress(account)
    ]);

    return result[0].toBigInt();
  }

  try_borrowCredit(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "borrowCredit",
      "borrowCredit(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  borrowedBASE(param0: Address): BigInt {
    let result = super.call("borrowedBASE", "borrowedBASE(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_borrowedBASE(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "borrowedBASE",
      "borrowedBASE(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  borrowedTotalBASE(): BigInt {
    let result = super.call(
      "borrowedTotalBASE",
      "borrowedTotalBASE():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_borrowedTotalBASE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "borrowedTotalBASE",
      "borrowedTotalBASE():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  currentPrice(): BigInt {
    let result = super.call("currentPrice", "currentPrice():(uint256)", []);

    return result[0].toBigInt();
  }

  try_currentPrice(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("currentPrice", "currentPrice():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  debt(account: Address): BigInt {
    let result = super.call("debt", "debt(address):(uint256)", [
      ethereum.Value.fromAddress(account)
    ]);

    return result[0].toBigInt();
  }

  try_debt(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("debt", "debt(address):(uint256)", [
      ethereum.Value.fromAddress(account)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  decimals(): i32 {
    let result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  decreaseAllowance(spender: Address, subtractedValue: BigInt): boolean {
    let result = super.call(
      "decreaseAllowance",
      "decreaseAllowance(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(spender),
        ethereum.Value.fromUnsignedBigInt(subtractedValue)
      ]
    );

    return result[0].toBoolean();
  }

  try_decreaseAllowance(
    spender: Address,
    subtractedValue: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "decreaseAllowance",
      "decreaseAllowance(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(spender),
        ethereum.Value.fromUnsignedBigInt(subtractedValue)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  factory(): Address {
    let result = super.call("factory", "factory():(address)", []);

    return result[0].toAddress();
  }

  try_factory(): ethereum.CallResult<Address> {
    let result = super.tryCall("factory", "factory():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  floorPrice(): BigInt {
    let result = super.call("floorPrice", "floorPrice():(uint256)", []);

    return result[0].toBigInt();
  }

  try_floorPrice(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("floorPrice", "floorPrice():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  gbtBal(): BigInt {
    let result = super.call("gbtBal", "gbtBal():(uint256)", []);

    return result[0].toBigInt();
  }

  try_gbtBal(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("gbtBal", "gbtBal():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getGumball(): Address {
    let result = super.call("getGumball", "getGumball():(address)", []);

    return result[0].toAddress();
  }

  try_getGumball(): ethereum.CallResult<Address> {
    let result = super.tryCall("getGumball", "getGumball():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getProtocol(): Address {
    let result = super.call("getProtocol", "getProtocol():(address)", []);

    return result[0].toAddress();
  }

  try_getProtocol(): ethereum.CallResult<Address> {
    let result = super.tryCall("getProtocol", "getProtocol():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  gumball(): Address {
    let result = super.call("gumball", "gumball():(address)", []);

    return result[0].toAddress();
  }

  try_gumball(): ethereum.CallResult<Address> {
    let result = super.tryCall("gumball", "gumball():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  gumbar(): Address {
    let result = super.call("gumbar", "gumbar():(address)", []);

    return result[0].toAddress();
  }

  try_gumbar(): ethereum.CallResult<Address> {
    let result = super.tryCall("gumbar", "gumbar():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  increaseAllowance(spender: Address, addedValue: BigInt): boolean {
    let result = super.call(
      "increaseAllowance",
      "increaseAllowance(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(spender),
        ethereum.Value.fromUnsignedBigInt(addedValue)
      ]
    );

    return result[0].toBoolean();
  }

  try_increaseAllowance(
    spender: Address,
    addedValue: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "increaseAllowance",
      "increaseAllowance(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(spender),
        ethereum.Value.fromUnsignedBigInt(addedValue)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  initSupply(): BigInt {
    let result = super.call("initSupply", "initSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_initSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("initSupply", "initSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  initial_totalSupply(): BigInt {
    let result = super.call(
      "initial_totalSupply",
      "initial_totalSupply():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_initial_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "initial_totalSupply",
      "initial_totalSupply():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  limit(param0: Address): BigInt {
    let result = super.call("limit", "limit(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_limit(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("limit", "limit(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  mustStayGBT(account: Address): BigInt {
    let result = super.call("mustStayGBT", "mustStayGBT(address):(uint256)", [
      ethereum.Value.fromAddress(account)
    ]);

    return result[0].toBigInt();
  }

  try_mustStayGBT(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "mustStayGBT",
      "mustStayGBT(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  name(): string {
    let result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  protocol(): Address {
    let result = super.call("protocol", "protocol():(address)", []);

    return result[0].toAddress();
  }

  try_protocol(): ethereum.CallResult<Address> {
    let result = super.tryCall("protocol", "protocol():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  reserveGBT(): BigInt {
    let result = super.call("reserveGBT", "reserveGBT():(uint256)", []);

    return result[0].toBigInt();
  }

  try_reserveGBT(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("reserveGBT", "reserveGBT():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  reserveRealBASE(): BigInt {
    let result = super.call(
      "reserveRealBASE",
      "reserveRealBASE():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_reserveRealBASE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "reserveRealBASE",
      "reserveRealBASE():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  reserveVirtualBASE(): BigInt {
    let result = super.call(
      "reserveVirtualBASE",
      "reserveVirtualBASE():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_reserveVirtualBASE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "reserveVirtualBASE",
      "reserveVirtualBASE():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  skimReward(): BigInt {
    let result = super.call("skimReward", "skimReward():(uint256)", []);

    return result[0].toBigInt();
  }

  try_skimReward(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("skimReward", "skimReward():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  symbol(): string {
    let result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  transfer(to: Address, amount: BigInt): boolean {
    let result = super.call("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(to),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);

    return result[0].toBoolean();
  }

  try_transfer(to: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(to),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFrom(from: Address, to: Address, amount: BigInt): boolean {
    let result = super.call(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferFrom(
    from: Address,
    to: Address,
    amount: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  treasuryBASE(): BigInt {
    let result = super.call("treasuryBASE", "treasuryBASE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_treasuryBASE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("treasuryBASE", "treasuryBASE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  treasuryGBT(): BigInt {
    let result = super.call("treasuryGBT", "treasuryGBT():(uint256)", []);

    return result[0].toBigInt();
  }

  try_treasuryGBT(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("treasuryGBT", "treasuryGBT():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  whitelist(param0: Address): boolean {
    let result = super.call("whitelist", "whitelist(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBoolean();
  }

  try_whitelist(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("whitelist", "whitelist(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class _whitelistCall extends ethereum.Call {
  get inputs(): _whitelistCall__Inputs {
    return new _whitelistCall__Inputs(this);
  }

  get outputs(): _whitelistCall__Outputs {
    return new _whitelistCall__Outputs(this);
  }
}

export class _whitelistCall__Inputs {
  _call: _whitelistCall;

  constructor(call: _whitelistCall) {
    this._call = call;
  }

  get accounts(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get _bool(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class _whitelistCall__Outputs {
  _call: _whitelistCall;

  constructor(call: _whitelistCall) {
    this._call = call;
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class BorrowMaxCall extends ethereum.Call {
  get inputs(): BorrowMaxCall__Inputs {
    return new BorrowMaxCall__Inputs(this);
  }

  get outputs(): BorrowMaxCall__Outputs {
    return new BorrowMaxCall__Outputs(this);
  }
}

export class BorrowMaxCall__Inputs {
  _call: BorrowMaxCall;

  constructor(call: BorrowMaxCall) {
    this._call = call;
  }
}

export class BorrowMaxCall__Outputs {
  _call: BorrowMaxCall;

  constructor(call: BorrowMaxCall) {
    this._call = call;
  }
}

export class BorrowSomeCall extends ethereum.Call {
  get inputs(): BorrowSomeCall__Inputs {
    return new BorrowSomeCall__Inputs(this);
  }

  get outputs(): BorrowSomeCall__Outputs {
    return new BorrowSomeCall__Outputs(this);
  }
}

export class BorrowSomeCall__Inputs {
  _call: BorrowSomeCall;

  constructor(call: BorrowSomeCall) {
    this._call = call;
  }

  get _amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class BorrowSomeCall__Outputs {
  _call: BorrowSomeCall;

  constructor(call: BorrowSomeCall) {
    this._call = call;
  }
}

export class BurnCall extends ethereum.Call {
  get inputs(): BurnCall__Inputs {
    return new BurnCall__Inputs(this);
  }

  get outputs(): BurnCall__Outputs {
    return new BurnCall__Outputs(this);
  }
}

export class BurnCall__Inputs {
  _call: BurnCall;

  constructor(call: BurnCall) {
    this._call = call;
  }

  get _amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class BurnCall__Outputs {
  _call: BurnCall;

  constructor(call: BurnCall) {
    this._call = call;
  }
}

export class BuyCall extends ethereum.Call {
  get inputs(): BuyCall__Inputs {
    return new BuyCall__Inputs(this);
  }

  get outputs(): BuyCall__Outputs {
    return new BuyCall__Outputs(this);
  }
}

export class BuyCall__Inputs {
  _call: BuyCall;

  constructor(call: BuyCall) {
    this._call = call;
  }

  get _amountBASE(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _minGBT(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get expireTimestamp(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class BuyCall__Outputs {
  _call: BuyCall;

  constructor(call: BuyCall) {
    this._call = call;
  }
}

export class DecreaseAllowanceCall extends ethereum.Call {
  get inputs(): DecreaseAllowanceCall__Inputs {
    return new DecreaseAllowanceCall__Inputs(this);
  }

  get outputs(): DecreaseAllowanceCall__Outputs {
    return new DecreaseAllowanceCall__Outputs(this);
  }
}

export class DecreaseAllowanceCall__Inputs {
  _call: DecreaseAllowanceCall;

  constructor(call: DecreaseAllowanceCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get subtractedValue(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class DecreaseAllowanceCall__Outputs {
  _call: DecreaseAllowanceCall;

  constructor(call: DecreaseAllowanceCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class IncreaseAllowanceCall extends ethereum.Call {
  get inputs(): IncreaseAllowanceCall__Inputs {
    return new IncreaseAllowanceCall__Inputs(this);
  }

  get outputs(): IncreaseAllowanceCall__Outputs {
    return new IncreaseAllowanceCall__Outputs(this);
  }
}

export class IncreaseAllowanceCall__Inputs {
  _call: IncreaseAllowanceCall;

  constructor(call: IncreaseAllowanceCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get addedValue(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class IncreaseAllowanceCall__Outputs {
  _call: IncreaseAllowanceCall;

  constructor(call: IncreaseAllowanceCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get __name(): string {
    return this._call.inputValues[0].value.toString();
  }

  get __symbol(): string {
    return this._call.inputValues[1].value.toString();
  }

  get _baseToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _initialVirtualBASE(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _supplyGBT(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _gumball(): Address {
    return this._call.inputValues[5].value.toAddress();
  }

  get _gumbar(): Address {
    return this._call.inputValues[6].value.toAddress();
  }

  get _artist(): Address {
    return this._call.inputValues[7].value.toAddress();
  }

  get _delay(): BigInt {
    return this._call.inputValues[8].value.toBigInt();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class RepayMaxCall extends ethereum.Call {
  get inputs(): RepayMaxCall__Inputs {
    return new RepayMaxCall__Inputs(this);
  }

  get outputs(): RepayMaxCall__Outputs {
    return new RepayMaxCall__Outputs(this);
  }
}

export class RepayMaxCall__Inputs {
  _call: RepayMaxCall;

  constructor(call: RepayMaxCall) {
    this._call = call;
  }
}

export class RepayMaxCall__Outputs {
  _call: RepayMaxCall;

  constructor(call: RepayMaxCall) {
    this._call = call;
  }
}

export class RepaySomeCall extends ethereum.Call {
  get inputs(): RepaySomeCall__Inputs {
    return new RepaySomeCall__Inputs(this);
  }

  get outputs(): RepaySomeCall__Outputs {
    return new RepaySomeCall__Outputs(this);
  }
}

export class RepaySomeCall__Inputs {
  _call: RepaySomeCall;

  constructor(call: RepaySomeCall) {
    this._call = call;
  }

  get _amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class RepaySomeCall__Outputs {
  _call: RepaySomeCall;

  constructor(call: RepaySomeCall) {
    this._call = call;
  }
}

export class SellCall extends ethereum.Call {
  get inputs(): SellCall__Inputs {
    return new SellCall__Inputs(this);
  }

  get outputs(): SellCall__Outputs {
    return new SellCall__Outputs(this);
  }
}

export class SellCall__Inputs {
  _call: SellCall;

  constructor(call: SellCall) {
    this._call = call;
  }

  get _amountGBT(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _minETH(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get expireTimestamp(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class SellCall__Outputs {
  _call: SellCall;

  constructor(call: SellCall) {
    this._call = call;
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TreasurySkimCall extends ethereum.Call {
  get inputs(): TreasurySkimCall__Inputs {
    return new TreasurySkimCall__Inputs(this);
  }

  get outputs(): TreasurySkimCall__Outputs {
    return new TreasurySkimCall__Outputs(this);
  }
}

export class TreasurySkimCall__Inputs {
  _call: TreasurySkimCall;

  constructor(call: TreasurySkimCall) {
    this._call = call;
  }
}

export class TreasurySkimCall__Outputs {
  _call: TreasurySkimCall;

  constructor(call: TreasurySkimCall) {
    this._call = call;
  }
}

export class UpdateOwnershipCall extends ethereum.Call {
  get inputs(): UpdateOwnershipCall__Inputs {
    return new UpdateOwnershipCall__Inputs(this);
  }

  get outputs(): UpdateOwnershipCall__Outputs {
    return new UpdateOwnershipCall__Outputs(this);
  }
}

export class UpdateOwnershipCall__Inputs {
  _call: UpdateOwnershipCall;

  constructor(call: UpdateOwnershipCall) {
    this._call = call;
  }
}

export class UpdateOwnershipCall__Outputs {
  _call: UpdateOwnershipCall;

  constructor(call: UpdateOwnershipCall) {
    this._call = call;
  }
}
