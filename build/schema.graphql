type Collection @entity {
  id: ID!
  tokenLibrary: Bytes!
  tokenProxy: Bytes!
  gumballProxy: Bytes!,
  tokenDeployed: Bytes!,
  name: String,
  symbol: String,
  price: BigInt!
  index: BigInt!,
  totalSupply: BigInt!,
  supplyCap: BigInt!,
  reserveGBT:BigInt!,
  gumbar: Bytes!,
  image: String!,
  factory: Bytes!,
  address:Bytes!,
  description:String!,
  whitelist: Boolean!,
  baseURI:String!,
  volume:BigDecimal!
  minted:BigInt!
  artist:Bytes!
  rewards: BigInt!
}

type Trade @entity {
  id: ID!
  amount: BigInt!
  currentPrice: BigInt!
  timestamp: BigInt
  eventType: String!
  collection: Bytes!
  name: String!
  user: Bytes!
}

type Swap @entity {
  id: ID!
  sender: Bytes! # address
  amount: BigInt!
  eventType: String!
  collection: Bytes!
}

type Token @entity{
  id: ID!
  tokenId: BigInt!
  tokenURI: String!
  collection: Bytes!
  imageURI:String!
  name:String!
  available: Boolean!
  owner:Bytes!
  attributes:[Attribute!]!
  baseURI: String
  staked: Boolean!
}

type Interval @entity {
  id: ID!
  time_frame: String!
  timestamp: String!
  collection: Bytes!
  trade_count: BigInt!
  price_sum: BigInt!
  average_price: BigInt!
  buy_events: BigInt!
  sell_events: BigInt!
}

type Attribute @entity {
  id: ID!
  trait_type: String!
  value: String!
  tokens: [Token!]! @derivedFrom(field: "attributes")
  collection: Bytes!
  count: BigInt!
}


type _Schema_
  @fulltext(
    name: "collectionSearch"
    language: en
    algorithm: proximityRank
    include: [
      {
        entity: "Collection"
        fields: [{ name: "name" }]
      }
    ]
  )